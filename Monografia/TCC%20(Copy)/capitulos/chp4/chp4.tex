Foi visto na seção sobre o PLL-Multitaxa que este é um método com grande eficácia no rastreio de frequências, porém é necessário saber onde elas estão, e isto o método não nos diz. Seria possível por exemplo utilizá-lo como um filtro de partículas e largar PLLs aleatoriamente pelo espectro do sinal, entretanto existem algumas formas de obter boas ideias de onde estão as componentes mais relevantes do sinal. Uma delas é a DFT ou a STFT com janelamento para reduzir o espalhamento pelo espectro, desta forma podemos identificar regiões do espectro onde sabemos que há energia relevante, sem saber no entanto a localização exata da componente, ou as componentes as quais pertence esta energia. Outro método visto na revisão foi o de Prony, do qual se fez uso no trabalho \cite{chang2009two}. Neste trabalho utilizou-se da otimização via RLS para resolver o problema da predição linear e calculou-se as raízes do polinômio característico do modelo Auto-Regressivo do sinal, assim foi possível obter as componentes relevantes com certa precisão.

\indent Neste mesmo trabalho, posteriormente se faz uso do RLS novamente para estimar a amplitude e fase de cada uma das componentes, alimentando o RLS com sinais senoidais em quadratura de modo que o filtro estimado fosse a amplitude de senoides e cossenoides.

\indent Nesta seção faremos a exposição de um método baseado no trabalho citado com algumas modificações.

\section{Solução em predição linear}

O método planteado na seção de Análise de Prony visa encontrar os coeficientes $w_m$ tais que:

\begin{equation}
u[k]=\sum_{m=1}^{M}w_m u[k-m]
\end{equation}

Que ao final é o equivalente a encontrar a matriz de autocorrelação e o vetor de correlação cruzada do sinal $u[k]$ na forma:

\begin{equation}
\boldsymbol{w}_{opt}=\boldsymbol{R}_{uu}^{-1}\boldsymbol{r}_{du}
\end{equation}

Onde desta vez o sinal de referência $d[k]$ ganha um caráter especial uma vez que é $u[k+1]$. Estas equação pode ser resolvida utilizando o método de Levinson–Durbin, para um determinado conjunto de dados. Mas também pode ser resolvida com os filtros adaptativos a cada iteração, fazendo um rastreio online destes parâmetros.

\section{Solução em RLS e NLMS}

Como visto anteriormente, o RLS faz uma estimação da matriz $\boldsymbol{R}_{uu}^{-1}$ a cada iteração e geralmente é o método que nos vai dar menor MSEe em menos tempo, entretanto ele tem algumas deficiências:

\begin{itemize}
	\item Se a matriz $\boldsymbol{R}_{uu}$ é singular ou não é bem ajustada, podemos ter problemas numéricos significativos, como a ordem dos elementos da matriz ser muito desbalanceada ou grande demais. Isso é bastante notável em nosso problema de estudo, pois em geral não se sabe a ordem do sistema que se está analisando, se este sistema tem uma ordem pequena e é estimado com um filtro grande, a matriz $\boldsymbol{R}_{uu}$ certamente será singular. Algo que pode ser feito para minimizar este problema é a adição de ruído;
	\item Em geral é mais lento para reagir a variações no sistema que o LMS;
	\item Tem uma complexidade computacional consideravelmente maior;
	\item Sua convergência é de certa forma caótica, perturbando o cálculo das raízes.
\end{itemize}

Deve-se também destacar que tanto o RLS quanto o NLMS se beneficiam de ordens de filtro próximas à quantidade de amostras por ciclo da fundamental. Isto se deve ao fato de que quanto menor são as variações dos sinais dentro do buffer $\boldsymbol{U}$ mais singular é a matriz de autocorrelação. 

\begin{figure}[h]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/convergencia_RLS_NLMS.pdf_tex}
	\caption{Convergência dos coeficientes RLS e NLMS na presença dos harmônicos 1, 3, 5 e 7; M=16}
	\label{fig:your image label}
\end{figure}

\begin{figure}[h]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/conv_comparacao.pdf_tex}
	\caption{Convergência do RLS e NLMS vista na estimação das frequências, com um degrau de 10 Hz em 500 amostras}
	\label{fig:your image label}
\end{figure}

Fazendo uma simulação com os harmônicos de 1 até 7, com a amplitude igual ao inverso de sua ordem e ruído gaussiano com $\sigma=0.02$, comparamos os resultados da divisão do menor pelo maior autovalor da matriz de autocorrelação estimada do sinal com diferentes valores de amostragem e ordem da matriz:

\begin{table}[H]
	\centering
	\begin{tabular}{l|l|l}
		   & M=16 & M=64 \\
		\hline 
		f0x16      & 1.3e-03 & 2.1e-04 \\
		f0x64      & 2.7e-04  & 8.6e-05       
	\end{tabular}
\end{table}

A tabela mostra o que já era esperado, e o que pode ser confirmado com outras simulações mais adiante, obtém-se resultados melhores com uma ordem de modelo menor e com menores taxas de amostragem.

\begin{figure}[h]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/erro_RLS_NLMS.pdf_tex}
	\caption{Convergência do RLS e NLMS na presença dos harmônicos 1, 3, 5 e 7; M=16}
	\label{fig:your image label}
\end{figure}

\section{Simulações}

\indent Foram realizadas simulações com os seguintes parâmetros: $f_s=32f0$, $M=32$, harmônicos de 1 a 15, pares e ímpares todos com amplitude unitária. E é considerada uma variação aleatória nestas frequências somando-lhes um valor aleatório de uma V.A gaussiana com determinada amplitude. Apresentamos na tabela abaixo os resultados de porcentagem de erro para o RLS e NLMS. Também foi agregado ao sinal um ruído gaussiano com $\sigma=0.02$. Depois de 15 ciclos do sinal é tomado o resultado:

\begin{table}[H]
	\centering
	\begin{tabular}{l|l|l}
	              & NLMS & RLS \\
		\hline 
		G(0, 0.1)  & 0     & 0 \\
		G(0, 0.25) & 1.9   & 2.3  \\
		G(0, 0.5)  & 18.4  & 3.4  \\
		G(0, 0.7)  & 22.8  & 6.8  \\
		G(0, 1)    & 28.3  & 10.2 \\ 
	\end{tabular}
	\caption{Resultados em \%}
\end{table}

\indent É considerado um erro quando não se encontra dentre os valores estimados nenhum correspondente com distância menor que 0.1 entre os valores corretos, de maneira também que uma vez pareada uma estimação com um valor real, este valor real não mais pode ser pareado com outra estimação. Assim podemos ter uma boa ideia da capacidade do algoritmo de classificar frequências diferentes, mas que estão bastante próximas.

\indent Também foram realizadas simulações para o caso de amplitude variável dos harmônicos, como uma V.A uniforme de 0 a 1.

\begin{table}[H]
	\centering
	\begin{tabular}{l|l|l}
		& NLMS & RLS \\
		\hline 
		G(0, 0.1)  & 3.4    & 0.6 \\
		G(0, 0.25) & 14.6   & 2.0  \\
		G(0, 0.5)  & 28.4  & 8.5  \\
		G(0, 0.7)  & 31.3  & 12.9  \\
		G(0, 1)    & 34.5  & 16.6 \\ 
	\end{tabular}
\caption{Simulação com amplitude variável, resultados em \%}
\end{table}

\section{Frequências próximas}

\begin{figure}[h]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/zoom_harmonicos.pdf_tex}
	\caption{Efeito de batimento em frequências muito próximas}
	\label{fig:your image label}
\end{figure}

\indent Frequências próximas em geral são um problema e o algoritmo tem bastante dificuldade em identificá-las. Muitas vezes estas são classificadas como sendo apenas uma. Uma maneira de resolver este problema é fazendo subamostragem do sinal e dividindo-o em partes por faixa de frequência, analisando posteriormente.

\indent O teste realizado seguiu este procedimento: foram sorteados harmônicos entre 0 e 15 com uma V.A uniforme, desta frequência foram geradas outras duas, $f_1=f_0+U_{0,1}$ e $f_2=f_0+U_{0,1}+\delta$, sendo $U_{0,1}$ uma V.A uniforme com amplitude 0.1. Os resultados podem ser vistos na tabela \ref{tab:tab_freq}.

\begin{table}[h]
	\centering
\begin{tabular}{|l|l|l|}
	\hline
	& RLS   & LMS        \\ \hline
	$\delta$ & erros(\%) & erros (\%) \\ \hline
	0.05  & 36,8  & 51,0       \\ \hline
	0.1   & 25,8  & 50,3       \\ \hline
	0.2   & 7,3   & 43,5       \\ \hline
	0.4   & 1,5   & 25,8       \\ \hline
	0.6   & 0,5   & 14,8       \\ \hline
	\end{tabular}
\caption{Tabela com os erros para classificação de frequências próximas}
\label{tab:tab_freq}
\end{table}

\section{Filtragem de valores}

Recuperando algumas equações do capítulo de referências, foi apresentado que o modelo estocástico do sinal Auto-Regressivo era da forma:

\begin{figure}[H]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/RLS_image.pdf_tex}
	\caption{Imagem com estimação de amplitudes e frequências no tempo usando RLS}
	\label{fig:im_RLS}
\end{figure}

\begin{equation}
u[k]=\sum_{m=1}^{M}w_m u[k-m] +\xi[n]
\end{equation}

Sendo $\xi$ ruído branco. Desta maneira pode-se desenvolver a equação para obter a transformada Z de $u[n]$:

\begin{equation}
U(z)=\sum_{m=1}^{M}w_m U(z)z^{-m} +\Xi(z)
\end{equation}
\begin{equation}
\frac{U(z)}{\Xi(z)}=\frac{1}{1-\sum_{m=1}^{M}w_m z^{-m}}
\label{eq:modelo_ar}
\end{equation}


A equação \ref{eq:modelo_ar} nos mostra que o a porção $Q(z)=1-\sum_{m=1}^{M}w_m z^{-m}$ determina as características espectrais de $U(w)$ uma vez que $\xi$ é ruído branco e tem densidade de potência constante para todo o espectro. Calculando $Q(w)^{-1}$ pode-se obter uma estimativa da energia naquele ponto. Assim se calcularmos $Q(w_{root})$ para todas  as raízes, é possível observar quais têm maior energia e quais têm menor. Desta forma está permitido até mesmo descartar a análise mais profunda de certas componentes que serão acusadas na estimação de frequências. Este tipo de análise inclusive é usado em processamento de fala para identificar formantes de fonemas, e por si só já um método de estimação espectral paramétrico.

Podemos ver nas imagens \ref{fig:im_RLS} e \ref{fig:im_NLMS} que a estimação feita desta forma para o RLS acusa muito mais frequências que não são reais de maneira aparentemente aleatória no decorrer do tempo, entretanto, ele converge muito mais rápido que o NLMS, que apresenta convergência suave e com pouco ruído. Em ambos os casos temos a presença do quinto e terceiro harmônicos que sofrem uma mudança brusca na frequência em t=2s.


\begin{figure}[H]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/NLMS_image.pdf_tex}
	\caption{Imagem com estimação de amplitudes e frequências no tempo usando NLMS}
	\label{fig:im_NLMS}
\end{figure}


\section{Teste de rastreio de frequências}

Faremos o mesmo teste de rastreio de frequências realizado no artigo citado. Usamos M=64, e $fs=64f_0$. Este teste consiste em um sinal com cinco componentes senoidais, três harmônicos da fundamental e dois inter-harmônicos na seguinte forma:

\begin{equation}
\begin{split}
	y(t)=A_1 sin(w_0 t+30º)+A_2 sin(3w_0 t+70º)+ A_3 sin(5w_0 t+40º) + \\ + 0.15 sin(w_1 t+135º)+ 0.1 sin(w_2 t + 175º) + \xi(t)
\end{split}
\end{equation}

Onde $A_1=1$, $A_2=1/3$, $A_3=1/5$, $w_0=f_0 2 \pi$ e $f_0=60 \, Hz$. Para os inter-harmônicos $f_1=152 \, Hz$ e $f_3= 266 \, Hz$. E $\xi(t)$=rand(t). 
\begin{itemize}
	\item Em $t=1.0 \,s$ as amplitudes dos harmônicos mudam para 0.8, 0.2 e 0.3 respectivamente; 
	\item Em $t=2.5 \,s$, $f_0$ vai para 59.8 Hz;
	\item em $t=4.0 \,s$, $f_0$ vai para 60.3 Hz e os harmônicos voltam a 1.0, 1/3 e 1/5 respectivamente;
	\item seguimos simulando até 5.5 s.
\end{itemize}

Os resultados podem ser vistos na figura abaixo: 

\begin{figure}[H]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/rastreio_final.pdf_tex}
	\caption{Rastreio com teste do artigo utilizando RLS}
	\label{fig:rastreio_final}
\end{figure}


Para o cálculo das raízes foi utilizada a função roots do MATLAB. Esta função não nos permite usar valores antigos como pontos inicias de busca pelas novas raízes, e no caso do RLS já vimos que este tem uma convergência bastante turbulenta, por assim dizer. Isso tudo faz com que muitas vezes uma mesma raiz seja calculada em ordens diferentes. Assim é necessário plantear um pequeno classificador muito simples para que se possa fazer o rastreio. Foi utilizado um classificador por distância, no qual utiliza-se os valores antigos presentes no mesmo para determinar qual das novas amostras pertence à posição 'n' do classificador. A cada iteração analisamos as novas estimações $\hat{f_i}[k]$ (frequência $i$ da iteração $k$) e as colocamos como uma nova evidência para a frequência mais próxima em valor absoluto no vetor de estimação global. E para reduzir o ruído de estimação, usamos uma soma convexa das estimativas antigas com a mais recente, da mesma maneira feita com o PLL.

\begin{equation}
	\hat{fglobal_n}=\hat{fglobal_{n-1}}(1-\lambda)-[argmin_{\hat{f_i}[k]}(|\hat{fglobal}_{n-1}-f_i[k]|)]\lambda
\end{equation}

\begin{figure}[H]
	\centering    
	\def\svgwidth{\columnwidth}
	\input{images/rastreio_60Hz.pdf_tex}
	\caption{Rastreio com teste do artigo utilizando RLS, componente fundamental}
	\label{fig:rastreio_final}
\end{figure}

\section{Complexidade computacional}

A complexidade computacional do RLS é de cerca de $3M^2 + 4M$ somas e multiplicações por iteração[14], enquanto que a do NLMS é de cerca de $4M$ somas e multiplicações. Apesar de a ordem de complexidade do NLMS ser bem menor, entre as operações do RLS há uma série de multiplicações e somas de matrizes, que podem ser otimizadas com computação em paralelo para determinados dispositivos. Então é de se rever onde vai ser aplicado o algoritmo, dependendo do hardware usado, o custo do RLS pode não ser tão mais alto que o do NLMS.

\section{Conclusões}
O algoritmo apresentado tem grande capacidade de estimação para determinados contextos. Por exemplo, com os harmônicos relativamente separados e com amplitude parecida, praticamente não há erros na estimação tanto no NLMS quanto no RLS. Claro que este contexto não é o que se vai encontrar muitas das vezes, mas pode-se fazer ajustes de taxa de amostragem e eliminação de algumas componentes caso seja necessário, tudo depende da natureza do problema. Em situações mais críticas, com grande desnível dos harmônicos e proximidade dos mesmos, o RLS acaba levando grande vantagem. Escolher um método ou o outro depende do hardware disponível e também da proposta desenvolvida. Foi mostrado ainda que o NLMS faz uma estimação mais estável dos coeficientes e consequentemente das raízes e harmônicos, a qual pode ser aproveitado para uma implementação online.
